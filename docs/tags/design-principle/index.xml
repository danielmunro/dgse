<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design principle on Dan's Software Engineering Handbook</title><link>http://sehandbook.com/tags/design-principle/</link><description>Recent content in design principle on Dan's Software Engineering Handbook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Jun 2021 20:34:32 -0700</lastBuildDate><atom:link href="http://sehandbook.com/tags/design-principle/index.xml" rel="self" type="application/rss+xml"/><item><title>Single Responsibility Principle</title><link>http://sehandbook.com/glossary/single-responsibility-principle/</link><pubDate>Tue, 22 Jun 2021 20:34:32 -0700</pubDate><guid>http://sehandbook.com/glossary/single-responsibility-principle/</guid><description>A logical section of code (function, class, module), should only ever have one reason to change.</description></item><item><title>Open/Closed Principle</title><link>http://sehandbook.com/glossary/open-closed-principle/</link><pubDate>Tue, 22 Jun 2021 20:32:42 -0700</pubDate><guid>http://sehandbook.com/glossary/open-closed-principle/</guid><description>The concept states that classes should be open for extension but closed for modification.</description></item><item><title>Liskov Substitution Principle</title><link>http://sehandbook.com/glossary/liskov-substitution-principle/</link><pubDate>Tue, 22 Jun 2021 20:29:10 -0700</pubDate><guid>http://sehandbook.com/glossary/liskov-substitution-principle/</guid><description>SOLID design principle. Relating to types. States essentially that if X is a subtype of Y, then X may be used in substitution of Y without concern for correctness or task performed.</description></item><item><title>Interface Segregation Principle</title><link>http://sehandbook.com/glossary/interface-segregation-principle/</link><pubDate>Tue, 22 Jun 2021 20:28:05 -0700</pubDate><guid>http://sehandbook.com/glossary/interface-segregation-principle/</guid><description>States that interfaces should remain small and focused. Interface implementations are then lightweight, and easy to create and maintain. Code that depends on interfaces that are small and focused in turn keep a smaller scope of responsibility.</description></item><item><title>Dependency Inversion</title><link>http://sehandbook.com/glossary/dependency-inversion/</link><pubDate>Mon, 21 Jun 2021 08:02:22 -0700</pubDate><guid>http://sehandbook.com/glossary/dependency-inversion/</guid><description>Classes should be provided their dependencies. Below is a trivial example of dependency inversion, using Kotlin:
1 2 3 4 5 class EmailService(private val emailClient: EmailClient) { fun sendEmail() { emailClient.send() } } This is compared to a system where class methods call external or global dependencies directly:
1 2 3 4 5 class EmailService { fun sendEmail() { EmailClient().send() } } There are a few benefits to dependency inversion.</description></item></channel></rss>